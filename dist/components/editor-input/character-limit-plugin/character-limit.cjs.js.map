{"version":3,"file":"character-limit.cjs.js","sources":["../../../../src/components/editor-input/character-limit-plugin/character-limit.tsx"],"sourcesContent":["import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { $trimTextContentFromAnchor } from '@lexical/selection';\nimport { $restoreEditorState } from '@lexical/utils';\nimport {\n\t$getSelection,\n\t$isRangeSelection,\n\tEditorState,\n\tRootNode,\n\t$getRoot,\n} from 'lexical';\nimport { useEffect } from 'react';\n\n// Function to calculate total content size including MentionNodes\nfunction calculateTotalContentSize( editorState: EditorState ): number {\n\t// Get normal text content size\n\tconst rootNode = $getRoot();\n\tconst textContentSize = rootNode.getTextContentSize();\n\n\t// Get mention count by checking for nodes with type 'mention'\n\tlet mentionContentSize = 0;\n\tconst nodeMap = editorState._nodeMap;\n\tfor ( const [ , node ] of nodeMap ) {\n\t\tif ( node.__type === 'mention' ) {\n\t\t\tmentionContentSize += 1;\n\t\t}\n\t}\n\t// Return combined size, counting each mention with the specified weight\n\treturn textContentSize + mentionContentSize;\n}\n\nexport function MaxLengthPlugin( { maxLength }: { maxLength: number } ): null {\n\tconst [ editor ] = useLexicalComposerContext();\n\n\tuseEffect( () => {\n\t\tlet lastRestoredEditorState: EditorState | null = null;\n\n\t\treturn editor.registerNodeTransform( RootNode, () => {\n\t\t\tconst selection = $getSelection();\n\t\t\tif ( ! $isRangeSelection( selection ) || ! selection.isCollapsed() ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst prevEditorState = editor.getEditorState();\n\t\t\tconst prevTextContentSize = prevEditorState.read( () =>\n\t\t\t\tcalculateTotalContentSize( prevEditorState )\n\t\t\t);\n\t\t\tconst textContentSize = calculateTotalContentSize( prevEditorState );\n\t\t\tif ( prevTextContentSize !== textContentSize ) {\n\t\t\t\tconst delCount = textContentSize - maxLength;\n\t\t\t\tconst anchor = selection.anchor;\n\n\t\t\t\tif ( delCount > 0 ) {\n\t\t\t\t\t// Restore the old editor state instead if the last\n\t\t\t\t\t// text content was already at the limit.\n\t\t\t\t\tif (\n\t\t\t\t\t\tprevTextContentSize === maxLength &&\n\t\t\t\t\t\tlastRestoredEditorState !== prevEditorState\n\t\t\t\t\t) {\n\t\t\t\t\t\tlastRestoredEditorState = prevEditorState;\n\t\t\t\t\t\t$restoreEditorState( editor, prevEditorState );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$trimTextContentFromAnchor( editor, anchor, delCount );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}, [ editor, maxLength ] );\n\n\treturn null;\n}\n\nexport default MaxLengthPlugin;\n"],"names":["calculateTotalContentSize","editorState","textContentSize","$getRoot","mentionContentSize","nodeMap","node","MaxLengthPlugin","maxLength","editor","useLexicalComposerContext","useEffect","lastRestoredEditorState","RootNode","selection","$getSelection","$isRangeSelection","prevEditorState","prevTextContentSize","delCount","anchor","$restoreEditorState","$trimTextContentFromAnchor"],"mappings":"yQAaA,SAASA,EAA2BC,EAAmC,CAGhE,MAAAC,EADWC,EAAAA,SAAS,EACO,mBAAmB,EAGpD,IAAIC,EAAqB,EACzB,MAAMC,EAAUJ,EAAY,SAC5B,SAAY,CAAA,CAAIK,CAAK,IAAKD,EACpBC,EAAK,SAAW,YACEF,GAAA,GAIxB,OAAOF,EAAkBE,CAC1B,CAEgB,SAAAG,EAAiB,CAAE,UAAAC,GAA2C,CACvE,KAAA,CAAEC,CAAO,EAAIC,4BAA0B,EAE7CC,OAAAA,EAAAA,UAAW,IAAM,CAChB,IAAIC,EAA8C,KAE3C,OAAAH,EAAO,sBAAuBI,EAAAA,SAAU,IAAM,CACpD,MAAMC,EAAYC,EAAAA,cAAc,EAChC,GAAK,CAAEC,EAAmB,kBAAAF,CAAU,GAAK,CAAEA,EAAU,cACpD,OAEK,MAAAG,EAAkBR,EAAO,eAAe,EACxCS,EAAsBD,EAAgB,KAAM,IACjDjB,EAA2BiB,CAAgB,CAC5C,EACMf,EAAkBF,EAA2BiB,CAAgB,EACnE,GAAKC,IAAwBhB,EAAkB,CAC9C,MAAMiB,EAAWjB,EAAkBM,EAC7BY,EAASN,EAAU,OAEpBK,EAAW,IAIdD,IAAwBV,GACxBI,IAA4BK,GAEFL,EAAAK,EAC1BI,EAAA,oBAAqBZ,EAAQQ,CAAgB,GAEjBK,6BAAAb,EAAQW,EAAQD,CAAS,EAEvD,CACD,CACC,CAAA,EACA,CAAEV,EAAQD,CAAU,CAAE,EAElB,IACR"}