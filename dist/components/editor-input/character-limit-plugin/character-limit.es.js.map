{"version":3,"file":"character-limit.es.js","sources":["../../../../src/components/editor-input/character-limit-plugin/character-limit.tsx"],"sourcesContent":["import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { $trimTextContentFromAnchor } from '@lexical/selection';\nimport { $restoreEditorState } from '@lexical/utils';\nimport {\n\t$getSelection,\n\t$isRangeSelection,\n\tEditorState,\n\tRootNode,\n\t$getRoot,\n} from 'lexical';\nimport { useEffect } from 'react';\n\n// Function to calculate total content size including MentionNodes\nfunction calculateTotalContentSize( editorState: EditorState ): number {\n\t// Get normal text content size\n\tconst rootNode = $getRoot();\n\tconst textContentSize = rootNode.getTextContentSize();\n\n\t// Get mention count by checking for nodes with type 'mention'\n\tlet mentionContentSize = 0;\n\tconst nodeMap = editorState._nodeMap;\n\tfor ( const [ , node ] of nodeMap ) {\n\t\tif ( node.__type === 'mention' ) {\n\t\t\tmentionContentSize += 1;\n\t\t}\n\t}\n\t// Return combined size, counting each mention with the specified weight\n\treturn textContentSize + mentionContentSize;\n}\n\nexport function MaxLengthPlugin( { maxLength }: { maxLength: number } ): null {\n\tconst [ editor ] = useLexicalComposerContext();\n\n\tuseEffect( () => {\n\t\tlet lastRestoredEditorState: EditorState | null = null;\n\n\t\treturn editor.registerNodeTransform( RootNode, () => {\n\t\t\tconst selection = $getSelection();\n\t\t\tif ( ! $isRangeSelection( selection ) || ! selection.isCollapsed() ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst prevEditorState = editor.getEditorState();\n\t\t\tconst prevTextContentSize = prevEditorState.read( () =>\n\t\t\t\tcalculateTotalContentSize( prevEditorState )\n\t\t\t);\n\t\t\tconst textContentSize = calculateTotalContentSize( prevEditorState );\n\t\t\tif ( prevTextContentSize !== textContentSize ) {\n\t\t\t\tconst delCount = textContentSize - maxLength;\n\t\t\t\tconst anchor = selection.anchor;\n\n\t\t\t\tif ( delCount > 0 ) {\n\t\t\t\t\t// Restore the old editor state instead if the last\n\t\t\t\t\t// text content was already at the limit.\n\t\t\t\t\tif (\n\t\t\t\t\t\tprevTextContentSize === maxLength &&\n\t\t\t\t\t\tlastRestoredEditorState !== prevEditorState\n\t\t\t\t\t) {\n\t\t\t\t\t\tlastRestoredEditorState = prevEditorState;\n\t\t\t\t\t\t$restoreEditorState( editor, prevEditorState );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$trimTextContentFromAnchor( editor, anchor, delCount );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}, [ editor, maxLength ] );\n\n\treturn null;\n}\n\nexport default MaxLengthPlugin;\n"],"names":["calculateTotalContentSize","editorState","textContentSize","$getRoot","mentionContentSize","nodeMap","node","MaxLengthPlugin","maxLength","editor","useLexicalComposerContext","useEffect","lastRestoredEditorState","RootNode","selection","$getSelection","$isRangeSelection","prevEditorState","prevTextContentSize","delCount","anchor","$restoreEditorState","$trimTextContentFromAnchor"],"mappings":";;;;;AAaA,SAASA,EAA2BC,GAAmC;AAGhE,QAAAC,IADWC,EAAS,EACO,mBAAmB;AAGpD,MAAIC,IAAqB;AACzB,QAAMC,IAAUJ,EAAY;AAC5B,aAAY,CAAA,EAAIK,CAAK,KAAKD;AACpB,IAAAC,EAAK,WAAW,cACEF,KAAA;AAIxB,SAAOF,IAAkBE;AAC1B;AAEgB,SAAAG,EAAiB,EAAE,WAAAC,KAA2C;AACvE,QAAA,CAAEC,CAAO,IAAIC,EAA0B;AAE7C,SAAAC,EAAW,MAAM;AAChB,QAAIC,IAA8C;AAE3C,WAAAH,EAAO,sBAAuBI,GAAU,MAAM;AACpD,YAAMC,IAAYC,EAAc;AAChC,UAAK,CAAEC,EAAmBF,CAAU,KAAK,CAAEA,EAAU;AACpD;AAEK,YAAAG,IAAkBR,EAAO,eAAe,GACxCS,IAAsBD,EAAgB;AAAA,QAAM,MACjDjB,EAA2BiB,CAAgB;AAAA,MAC5C,GACMf,IAAkBF,EAA2BiB,CAAgB;AACnE,UAAKC,MAAwBhB,GAAkB;AAC9C,cAAMiB,IAAWjB,IAAkBM,GAC7BY,IAASN,EAAU;AAEzB,QAAKK,IAAW,MAIdD,MAAwBV,KACxBI,MAA4BK,KAEFL,IAAAK,GAC1BI,EAAqBZ,GAAQQ,CAAgB,KAEjBK,EAAAb,GAAQW,GAAQD,CAAS;AAAA,MAEvD;AAAA,IACD,CACC;AAAA,EAAA,GACA,CAAEV,GAAQD,CAAU,CAAE,GAElB;AACR;"}