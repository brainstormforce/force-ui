{"version":3,"file":"mention-hooks.cjs.js","sources":["../../../../src/components/editor-input/mention-plugin/mention-hooks.ts"],"sourcesContent":["import { useEffect, useState, useRef } from 'react';\nimport { OptionsArray } from './mention-plugin';\n\n// Wrapper class for string keys\nclass StringKey {\n\tvalue: string;\n\n\tconstructor( value: string ) {\n\t\tthis.value = value;\n\t}\n}\n\ntype TBy<T> =\n\tT extends Array<infer U>\n\t\t? U extends Record<string, unknown>\n\t\t\t? keyof U & ( string & {} )\n\t\t\t: string\n\t\t: string;\n\nfunction useMentionLookupService<T = OptionsArray>(\n\toptions: T,\n\tmentionString: string | null,\n\tby: TBy<T> = 'name' as TBy<T>\n): OptionsArray {\n\tconst [ results, setResults ] = useState<OptionsArray>( [] );\n\n\t// Create instance-specific cache using WeakMap\n\tconst mentionsCacheRef = useRef<WeakMap<StringKey, OptionsArray | null>>(\n\t\tnew WeakMap()\n\t);\n\n\t// Store reference to key objects\n\tconst keysRef = useRef<Map<string, StringKey>>( new Map() );\n\n\t// Track the previous options reference\n\tconst prevOptionsRef = useRef<T>( options );\n\n\t// Clear cache when options change\n\tuseEffect( () => {\n\t\t// Check if options actually changed (not just re-rendered with same data)\n\t\tif ( prevOptionsRef.current !== options ) {\n\t\t\t// Options changed, clear cache\n\t\t\tmentionsCacheRef.current = new WeakMap();\n\t\t\tkeysRef.current.clear();\n\t\t\tprevOptionsRef.current = options;\n\n\t\t\t// Re-run search if we have an active search\n\t\t\tif ( mentionString !== null ) {\n\t\t\t\t// Trigger search with new options\n\t\t\t\tlookupService.search(\n\t\t\t\t\toptions,\n\t\t\t\t\tmentionString,\n\t\t\t\t\t( newResults ) => {\n\t\t\t\t\t\tsetResults( newResults as OptionsArray );\n\t\t\t\t\t},\n\t\t\t\t\tby\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}, [ options, by, mentionString ] );\n\n\tuseEffect( () => {\n\t\tif ( mentionString === null ) {\n\t\t\tsetResults( [] );\n\t\t\treturn;\n\t\t}\n\n\t\tconst mentionsCache = mentionsCacheRef.current;\n\t\tconst keysMap = keysRef.current;\n\n\t\t// Get or create key object for this string\n\t\tlet keyObj = keysMap.get( mentionString );\n\t\tif ( ! keyObj ) {\n\t\t\tkeyObj = new StringKey( mentionString );\n\t\t\tkeysMap.set( mentionString, keyObj );\n\t\t}\n\n\t\tconst cachedResults = mentionsCache.get( keyObj );\n\t\tif ( cachedResults === null ) {\n\t\t\treturn;\n\t\t} else if ( cachedResults !== undefined ) {\n\t\t\tsetResults( cachedResults );\n\t\t\treturn;\n\t\t}\n\n\t\tmentionsCache.set( keyObj, null );\n\t\tlookupService.search(\n\t\t\toptions,\n\t\t\tmentionString,\n\t\t\t( newResults ) => {\n\t\t\t\t// Ensure the key object still exists\n\t\t\t\tconst currentKeyObj = keysMap.get( mentionString );\n\t\t\t\tif ( currentKeyObj ) {\n\t\t\t\t\tmentionsCache.set(\n\t\t\t\t\t\tcurrentKeyObj,\n\t\t\t\t\t\tnewResults as OptionsArray\n\t\t\t\t\t);\n\t\t\t\t\tsetResults( newResults as OptionsArray );\n\t\t\t\t}\n\t\t\t},\n\t\t\tby\n\t\t);\n\n\t\t// Periodically clean up old keys\n\t\tif ( keysMap.size > 100 ) {\n\t\t\tconst keysToKeep = Array.from( keysMap.entries() ).slice( -50 );\n\t\t\tkeysRef.current = new Map( keysToKeep );\n\t\t}\n\t}, [ mentionString, options, by ] );\n\n\treturn results;\n}\n\nconst lookupService = {\n\tsearch<T = OptionsArray>(\n\t\toptions: T,\n\t\tstring: string,\n\t\tcallback: ( result: T ) => void,\n\t\tby: T extends Array<infer U>\n\t\t\t? U extends Record<string, unknown>\n\t\t\t\t? keyof U\n\t\t\t\t: string\n\t\t\t: string\n\t) {\n\t\tsetTimeout( () => {\n\t\t\tif ( ! Array.isArray( options ) ) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\tconst results = options.filter(\n\t\t\t\t( mention: string | Record<string, unknown> ) => {\n\t\t\t\t\tif ( typeof mention === 'string' ) {\n\t\t\t\t\t\treturn mention\n\t\t\t\t\t\t\t.toLowerCase()\n\t\t\t\t\t\t\t.includes( string.toLowerCase() );\n\t\t\t\t\t}\n\n\t\t\t\t\tconst strValue = mention?.[ by ]?.toString();\n\t\t\t\t\tif ( ! strValue ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn strValue\n\t\t\t\t\t\t.toLowerCase()\n\t\t\t\t\t\t.includes( string.toLowerCase() );\n\t\t\t\t}\n\t\t\t);\n\t\t\tcallback( results as T );\n\t\t}, 500 );\n\t},\n};\n\nexport default useMentionLookupService;\n"],"names":["StringKey","value","useMentionLookupService","options","mentionString","by","results","setResults","useState","mentionsCacheRef","useRef","keysRef","prevOptionsRef","useEffect","lookupService","newResults","mentionsCache","keysMap","keyObj","cachedResults","currentKeyObj","keysToKeep","string","callback","mention","strValue"],"mappings":"qIAIA,MAAMA,CAAU,CACf,MAEA,YAAaC,EAAgB,CAC5B,KAAK,MAAQA,CACd,CACD,CASA,SAASC,EACRC,EACAC,EACAC,EAAa,OACE,CACf,KAAM,CAAEC,EAASC,CAAW,EAAIC,EAAAA,SAAwB,CAAA,CAAG,EAGrDC,EAAmBC,EAAAA,WACpB,OAAQ,EAIPC,EAAUD,EAAAA,OAAgC,IAAI,GAAM,EAGpDE,EAAiBF,EAAAA,OAAWP,CAAQ,EAG1CU,OAAAA,EAAAA,UAAW,IAAM,CAEXD,EAAe,UAAYT,IAE/BM,EAAiB,YAAc,QAC/BE,EAAQ,QAAQ,MAAA,EAChBC,EAAe,QAAUT,EAGpBC,IAAkB,MAEtBU,EAAc,OACbX,EACAC,EACEW,GAAgB,CACjBR,EAAYQ,CAA2B,CACxC,EACAV,CAAA,EAIJ,EAAG,CAAEF,EAASE,EAAID,CAAc,CAAE,EAElCS,EAAAA,UAAW,IAAM,CAChB,GAAKT,IAAkB,KAAO,CAC7BG,EAAY,CAAA,CAAG,EACf,MACD,CAEA,MAAMS,EAAgBP,EAAiB,QACjCQ,EAAUN,EAAQ,QAGxB,IAAIO,EAASD,EAAQ,IAAKb,CAAc,EACjCc,IACNA,EAAS,IAAIlB,EAAWI,CAAc,EACtCa,EAAQ,IAAKb,EAAec,CAAO,GAGpC,MAAMC,EAAgBH,EAAc,IAAKE,CAAO,EAChD,GAAKC,IAAkB,KAEvB,IAAYA,IAAkB,OAAY,CACzCZ,EAAYY,CAAc,EAC1B,MACD,CAqBA,GAnBAH,EAAc,IAAKE,EAAQ,IAAK,EAChCJ,EAAc,OACbX,EACAC,EACEW,GAAgB,CAEjB,MAAMK,EAAgBH,EAAQ,IAAKb,CAAc,EAC5CgB,IACJJ,EAAc,IACbI,EACAL,CAAA,EAEDR,EAAYQ,CAA2B,EAEzC,EACAV,CAAA,EAIIY,EAAQ,KAAO,IAAM,CACzB,MAAMI,EAAa,MAAM,KAAMJ,EAAQ,SAAU,EAAE,MAAO,GAAI,EAC9DN,EAAQ,QAAU,IAAI,IAAKU,CAAW,CACvC,EACD,EAAG,CAAEjB,EAAeD,EAASE,CAAG,CAAE,EAE3BC,CACR,CAEA,MAAMQ,EAAgB,CACrB,OACCX,EACAmB,EACAC,EACAlB,EAKC,CACD,WAAY,IAAM,CACjB,GAAK,CAAE,MAAM,QAASF,CAAQ,EAC7B,MAAO,CAAA,EAER,MAAMG,EAAUH,EAAQ,OACrBqB,GAA+C,CAChD,GAAK,OAAOA,GAAY,SACvB,OAAOA,EACL,YAAA,EACA,SAAUF,EAAO,aAAc,EAGlC,MAAMG,EAAWD,IAAWnB,CAAG,GAAG,SAAA,EAClC,OAAOoB,EAGAA,EACL,YAAA,EACA,SAAUH,EAAO,aAAc,EAJzB,EAKT,CAAA,EAEDC,EAAUjB,CAAa,CACxB,EAAG,GAAI,CACR,CACD"}